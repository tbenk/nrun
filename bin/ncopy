#!/usr/bin/perl
#
# Copyright 2013 Timo Benk
# 
# This file is part of nrun.
# 
# nrun is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# nrun is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with nrun.  If not, see <http://www.gnu.org/licenses/>.
#
# Program: <FILE>
# Author:  <AUTHORNAME> <<AUTHOREMAIL>>
# Date:    <COMMITTERDATE>
# Ident:   <COMMITHASH>
# Branch:  <BRANCH>
#
# <CHANGELOG:--reverse --grep '^tags.*relevant':-1:%an : %ai : %s>
#

package Main;

use strict;
use warnings;

use FindBin;
use lib "$FindBin::Bin/../lib";

use File::Path;
use File::Basename;
use Date::Format;
use Getopt::Long;
use Net::Ping;
use POSIX qw(getuid);

use NRun::Worker;
use NRun::Dumper;
use NRun::Logger;
use NRun::Dispatcher;

our $options = {};

###
# dump a short usage info to stdout.
sub usage {

    print "usage: " . basename($0) . " -s <SRC> -d <DST> [-h <HOSTS>] <HOST1> <HOST2> ...\n";
    print "--hosts-file,-h <HOSTS>    file containing the target hosts (one host per line).\n";
    print "--source,-s <SRC>          the file to be copied.\n";
    print "--destination,-d <DST>     destination the file should be copied to.\n";
    print "--parallel,-p <MAX>        number of parallel connections (defaults to 5).\n";
    print "--dump-results             instead of dumping the command output, dump the exit status.\n";
    print "--log-directory,-l <DIR>   base directory for the log files.\n";
    print "--timeout,-t <SEC>         timeout for each command execution (defaults to 60).\n";
    print "--no-hostname              omit hostname prefix.\n";
    print "--no-logfile               do not generate any log files.\n";
    print "--skip-ping-check          skip checking if the host answers on ping.\n";
    print "--skip-ns-check            skip checking if the hostname is resolvable.\n";
    print "--mode <MODE>              remote execution mode:\n";

    foreach my $object (values(%{NRun::Worker::workers()})) {

        print "                           " . $object->mode() . " - " . $object->desc() ."\n";
    }

    exit;
}

###
# parse the commandline.
sub parse_commandline {

    my $arg_hosts_file      = $options->{arg_hosts_file};
    my $arg_parallel        = $options->{arg_parallel};
    my $arg_source          = $options->{arg_source};
    my $arg_destination     = $options->{arg_destination};
    my $arg_dump_results    = $options->{arg_dump_results};
    my $arg_no_hostname     = $options->{arg_no_hostname};
    my $arg_no_logfile      = $options->{arg_no_logfile};
    my $arg_log_directory   = $options->{arg_log_directory};
    my $arg_mode            = $options->{arg_mode};
    my $arg_skip_ping_check = $options->{arg_skip_ping_check};
    my $arg_skip_ns_check   = $options->{arg_skip_ns_check};
    my $arg_timeout         = $options->{arg_timeout};

    my $ret = GetOptions (
        "hosts-file|h=s"    => \$arg_hosts_file,
        "parallel|p=i"      => \$arg_parallel,
        "source|s=s"        => \$arg_source,
        "destination|d=s"   => \$arg_destination,
        "no-hostname"       => \$arg_no_hostname,
        "dump-results"      => \$arg_dump_results,
        "log-directory|l=s" => \$arg_log_directory,
        "timeout|t=i"       => \$arg_timeout,
        "no-logfile"        => \$arg_no_logfile,
        "mode|m=s"          => \$arg_mode,
        "skip-ping-check"   => \$arg_skip_ping_check,
        "skip-ns-check"     => \$arg_skip_ns_check,
    );

    usage() if (not $ret);

    if (not defined($arg_source)) {

        print "error: parameter --source is mandatory.\n";
        usage();
    }

    if (not defined($arg_destination)) {

        print "error: parameter --destination is mandatory.\n";
        usage();
    }

    if (not defined($arg_mode)) {

        print "error: parameter --mode is mandatory.\n";
        usage();
    }

    my $date = time2str("%Y%m%d_%H_%M_%S", time);

    $options->{hosts_file}      = $arg_hosts_file;
    $options->{parallel}        = $arg_parallel;
    $options->{source}          = $arg_source;
    $options->{destination}     = $arg_destination;
    $options->{timeout}         = $arg_timeout;
    $options->{no_logfile}      = $arg_no_logfile;
    $options->{skip_ns_check}   = $arg_skip_ns_check;
    $options->{skip_ping_check} = $arg_skip_ping_check;
    $options->{mode}            = lc($arg_mode);

    $options->{dump} = "output";
    if (defined($arg_dump_results)) {
    
        $options->{dump} = "result";
    } elsif (defined($arg_no_hostname)) {

        $options->{dump} = "output_no_hostname";
    }

    $options->{log_directory} = "copy/" . $date;
    if (defined($arg_log_directory)) {

        $options->{log_directory} = "$arg_log_directory/$options->{log_directory}";
    } else {

        $options->{log_directory} = home() . "/.nrun/$options->{log_directory}";
    }

    if ($options->{parallel} < 1) {

        print "error: parameter --parallel must be bigger than 1.\n";
        usage();
    }

    $options->{hosts} = \@ARGV ;
    if (defined($arg_hosts_file)) {
    
        $options->{hosts} = [ read_hosts($arg_hosts_file), @ARGV ];
    }

    if (scalar(@{$options->{hosts}}) == 0) {

        print "error: no hostnames given.\n";
        usage();
    }
}

###
# return users home directory
#
# <- the current users home directory
sub home {

    my $home = (getpwuid(getuid()))[7];
}

###
# read the hosts file.
#
# $_file - the file containing the hostnames, one per line
# <- an array containing all hostnames
sub read_hosts {

    my $_file = shift;

    my $hosts = {};

    open(HOSTS, "<$_file") or die("Cannot open $_file: $!");
    foreach my $host (<HOSTS>) {

        chomp($host);
        $host =~ s/^\s+//;
        $host =~ s/\s+$//;

        if (not $host =~ /^ *$/) {

            # filter out duplicate entries
            $hosts->{$host} = 1;
        }
    }

    return keys(%$hosts);
}

###
# callback function used by the dispatcher
sub callback_action {
    
    my $_host = shift;

    if (not (defined($options->{skip_ns_check}) or gethostbyname($_host))) {

        return (-254, "dns entry is missing");
    }

    if (not (defined($options->{skip_ping_check}) or Net::Ping->new()->ping($_host))) {

        return (-253, "not pinging");
    }

    return NRun::Worker::workers()->{$options->{mode}}->copy($_host, $options->{source}, $options->{destination});
}

###
# callback function used by the dispatcher
sub callback_result {

    my $_host   = shift;
    my $_return = shift;
    my $_output = shift;

    my $dumper = NRun::Dumper->new (
        {
            dump => $options->{dump},
        }
    );

    $dumper->dump($_host, $_return, $_output);

    my $logger = NRun::Logger->new (
        {
            basedir => $options->{log_directory},
        }
    );

    $logger->log($_host, $_return, $_output) if (not defined($options->{no_logfile}));
}

##
# read configuration files
#
# $_files - the files to be read (values in last file will overwrite values in first file)
sub read_config_files {

    my $_files = shift;

    foreach my $file (@$_files) {
  
        if (-e $file) {
  
            require $file;
        }
    }
}

###
# main
sub main {

    read_config_files (
        [
            "$FindBin::Bin/../etc/nrun.config",
            "/etc/nrun.config",
            home() . "/.nrun.config" 
        ]
    );

    NRun::Worker::load_modules($options);

    parse_commandline();

    my $dispatcher = NRun::Dispatcher->new (
        {
            nmax    => $options->{parallel},
            timeout => $options->{timeout},
            objects => $options->{hosts},
    
            callback_action => \&callback_action,
            callback_result => \&callback_result,
        }
    );

    $dispatcher->run();
}

main();
